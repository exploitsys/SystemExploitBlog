---
title: "ICALL ABUSE TO EVADE AC?"
date: 2024-02-5T22:30:00-03:00
description: "A exploit in windows kernel that will allow you to evade anticheat!"
tags: [LeagueOfLegends]
---

## MUST READ
This is souly for education purposes only. I am not posting this for financial gain or to destroy League of Legends. 
I am simply pointing out flaws in their security!


# Introduction
It has been awhile since I made a post. I am truly sorry I will try and become more frequent! But to get started today we will be talking about a gadget I found that will allow us to communicate in our driver using a data-ptr while actually staying hidden to the anticheats

# What we will cover
- Why gadgets?
- What is an icall?
- Shellcode.
- Implementation.

# Should Know
- Intel x64 ASM
- C++/C
- Windows Internals


# Why gadgets?
This will allow us to communicate without anticheats being able to statically traverse our hook and see what we are doing inside of our communication threads. You should note this doesnt make you UD(Undetected), it will only make it so that cant traverse your communication there are still ways for them to see what youre doing but for BE and RICOCHET you should be fine.


# Our gadget/what is an icall
So after looking in IDA I came across this code and as you can see it calls a function called _guard_dispatch_icall_ptr. The icall basically is a jmp to rax. So you can already see why this would be so much better then normally just jumping directly to our code this does it for us. 
![ICALL](https://cdn.discordapp.com/attachments/1130603399293976797/1204191936303603712/dataptrgadget.png?ex=65d3d622&is=65c16122&hm=5dc4028c16551634d26095909cd045eefbc9a49250cb113b290fe84e62dc28c4&)

# Our Shellcode
We can modify this function to basically call our handler by setting rax to a ptr to our handler function(0xdeadbeef is used as a placeholder). By doing this it will call the jmp to rax and execute our code. Here is the shellcode I came up with  you can really do anything as long as you keep your shellcode the exact same size of bytes as the code we are modifying.  
```asm
 sub    rsp,0x38
 movabs rax,0xdeadbeef #placeholder for handler
 movabs r10,0xab39cfee
 inc    rax
 dec    rax
 call   QWORD PTR [rip+0x720d4]        # 0x720f8
 jmp    0x29
```
After you have made your shellcode youre going to have to convert it to byte form

# Implementation
 To impliment this we are going to do some things inside of driver. I chose to do this in cpp but you can do this in c aswell if you would like to. We are going to need to swap 0xdeadbeef with a ptr to our function then copy our shellcode into the function we are abusing.
 ```cpp
u64 module = utils::GetSystemModule(L"win32k.sys");

FunctionAddress = module + 0xD70C; //our function

//asm in byte form
BYTE shellcode[] = { 0x48, 0x83, 0xEC, 0x38, 0x48, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x49, 0xBA, 0xEE, 0xCF, 0x39, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x48, 0xFF, 0xC0, 0x48, 0xFF, 0xC8, 0xFF, 0x15, 0xD4, 0x20, 0x07, 0x00, 0xE9, 0x00, 0x00, 0x00, 0x00 };

memcpy(&shellcode[6], &hkfunction, 8);
DisableWriteProtection(); //to avoid problems with PG
memcpy((PVOID)FunctionAddress, &shellcode, sizeof(shellcode));
EnableWriteProtection();
 ```
Things to note you will need to repair the stack or else from time to time youre going to have issues with bluescreening. To achieve this inside of your handler instead of returning just do the operations the funciton would do if you did not modify it. I wont spoonfeed the code it should be pretty self explanitory


# Summery
This is just one of many ways you can abuse ICALL gadgets in the windows kernel make sure to join our discord and show us cool things you have done using them!
